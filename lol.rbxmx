<roblox version="4">
  <Item class="ModuleScript" referent="0">
    <Properties>
      <string name="Name">ParseServer</string>
      <string name="Source"><![CDATA[local _config = require(script._config)
local tableJoin = require(script.Util.tableJoin)

local Objects = require(script.Objects)

local ParseServer = {}

function ParseServer.new()
	local self = {}
	
	function self:setBaseUrl(baseUrl)
		_config.data.baseUrl = baseUrl
		return self
	end
	
	function self:setAppId(appId)
		_config.data.appId = appId
		return self
	end
	
	return tableJoin(self, {
		Objects = Objects
	})	
end


return ParseServer
]]></string>
    </Properties>
    <Item class="ModuleScript" referent="1">
      <Properties>
        <string name="Name">Objects</string>
        <string name="Source"><![CDATA[local _config = require(script.Parent._config)
local HttpService = game:GetService("HttpService")

local withClassName = require(script.Parent.Util.withClassName)

local Query = require(script.Parent.Query)

local Objects = {}

function Objects.class(className)	
	local self = {}
	
	function self:create(object)
		local url = withClassName(className)
		local response = HttpService:RequestAsync({
			Url = url,
			Method = "POST",
			Headers = _config:getHeaders(),
			Body = HttpService:JSONEncode(object)
		})
		
		return HttpService:JSONDecode(response.Body)
	end
	
	function self:get(objectId)
		local url = withClassName(className, objectId)
		local response = HttpService:RequestAsync({
			Url = url,
			Method = "GET",
			Headers = _config:getHeaders()
		})
		
		if response.Success then
			return HttpService:JSONDecode(response.Body).results, false
		end
		
		return HttpService:JSONDecode(response.Body), false
	end
	
	function self:update(objectId, updateDocument)
		local url = withClassName(className, objectId)
		local response = HttpService:RequestAsync({
			Url = url,
			Method = "PUT",
			Body = HttpService:JSONEncode(updateDocument),
			Headers = _config:getHeaders()
		})
		
		return HttpService:JSONDecode(response.Body)
	end
	
	function self:query()
		return Query.new(className)
	end
	
	function self:delete(objectId)
		local url = withClassName(className, objectId)
		local response = HttpService:RequestAsync({
			Url = url,
			Method = "DELETE",
			Headers = _config:getHeaders()
		})

		return HttpService:JSONDecode(response.Body)
	end
	
	return self
end

return Objects
]]></string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="2">
      <Properties>
        <string name="Name">Query</string>
        <string name="Source"><![CDATA[local _config = require(script.Parent._config)
local HttpService = game:GetService("HttpService")

local withClassName = require(script.Parent.Util.withClassName)

local Query = {}

function Query.new(className)
	local query = {}

	local fields = {}

	local url = withClassName(className)

	function query:where(where)
		fields.where = where
		return self
	end
	
	function query:order(field)
		fields.order = field
		return self
	end
	
	function query:skip(number)
		fields.skip = number
		return self
	end
	
	function query:excludeKeys(keys)
		fields.excludeKeys = table.concat(keys, ",")
		return self
	end
	
	function query:keys(keys)
		fields.keys = table.concat(keys, ",")
		return self
	end
	
	function query:include(keys)
		fields.include = table.concat(keys, ",")
		return self
	end

	function query:execute()
		local fieldNumber = 0
		for k, v in pairs(fields) do
			fieldNumber += 1
			local delimiter = (fieldNumber == 1) and "?" or "&"
			
			if typeof(v) == "table" then
				local serialized = HttpService:JSONEncode(v)
				url ..= string.format("%s%s=%s", delimiter, k, HttpService:UrlEncode(serialized))
			else
				url ..= string.format("%s%s=%s", delimiter, k, HttpService:UrlEncode(v))
			end
		end

		local response = HttpService:RequestAsync({
			Url = url,
			Method = "GET",
			Headers = _config:getHeaders()
		})

		if response.Success then
			return HttpService:JSONDecode(response.Body).results, true
		end

		return HttpService:JSONDecode(response.Body), false
	end

	return query
end

return Query
]]></string>
      </Properties>
    </Item>
    <Item class="Folder" referent="3">
      <Properties>
        <string name="Name">Util</string>
      </Properties>
      <Item class="ModuleScript" referent="4">
        <Properties>
          <string name="Name">tableJoin</string>
          <string name="Source">return function(t1, t2)
	local ret = {}
	
	for i, v in pairs(t1) do
		ret[i] = v
	end
	
	for i, v in pairs(t2) do
		ret[i] = v
	end
	
	return ret
end</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="5">
        <Properties>
          <string name="Name">withClassName</string>
          <string name="Source">local _config = require(script.Parent.Parent._config)
local HttpService = game:GetService("HttpService")

local function withClassName(className, endpoint)
	if endpoint then
		return _config:withBaseUrl(string.format("/classes/%s/%s", className, endpoint))
	end
	return _config:withBaseUrl(string.format("/classes/%s", className))
end

return withClassName</string>
        </Properties>
      </Item>
    </Item>
    <Item class="ModuleScript" referent="6">
      <Properties>
        <string name="Name">_config</string>
        <string name="Source"><![CDATA[local tableJoin = require(script.Parent.Util.tableJoin)

local _config = {}

_config.data = {
	appId = "",
	baseUrl = ""
}

function _config:getHeaders(extraHeaders)
	local headers = {
		["X-Parse-Application-Id"] = self.data.appId,
		["Content-Type"] = "application/json"
	}
	
	if extraHeaders == "table" then
		headers = tableJoin(headers, extraHeaders)
	end
	
	return headers
end

function _config:withBaseUrl(endpoint)
	return string.format("%s%s", self.data.baseUrl, endpoint)
end

return _config
]]></string>
      </Properties>
    </Item>
  </Item>
</roblox>